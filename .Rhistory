permutazione <- sample(n)
Y.perm.glob <- Y[permutazione]
permutazione
# in this case permuting the responses or the residuals is the same
res.H0glob <- Y - mean(Y)
Y.perm.glob
mean(Y) + res.H0glob[permutazione]
layout(matrix(1:6,nrow=3,byrow=FALSE))
plot(x1,Y,main='Y vs x1 (original data)',pch=16)
plot(x2,Y,main='Y vs x2 (original data)',pch=16)
plot(x3,Y,main='Y vs x3 (original data)',pch=16)
plot(x1,Y.perm.glob,main='Y vs x1 (permuted data)',pch=16)
plot(x2,Y.perm.glob,main='Y vs x2 (permuted data)',pch=16)
plot(x3,Y.perm.glob,main='Y vs x3 (permuted data)',pch=16)
summary(result)$coefficients
T0_x1 <- abs(summary(result)$coefficients[2,3])
T0_x1
regr.H01 <- lm(Y ~ x2 + x3)
residui.H01 <- regr.H01$residuals
residui.H01.perm <- residui.H01[permutazione]
# permuted y:
Y.perm.H01 <- regr.H01$fitted + residui.H01.perm
layout(matrix(1:6,nrow=3,byrow=FALSE))
plot(x1,Y,main='Y vs x1 (original data)',pch=16)
plot(x2,Y,main='Y vs x2 (original data)',pch=16)
plot(x3,Y,main='Y vs x3 (original data)',pch=16)
plot(x1,Y.perm.H01,main='Y vs x1 (permuted data)',pch=16)
plot(x2,Y.perm.H01,main='Y vs x2 (permuted data)',pch=16)
plot(x3,Y.perm.H01,main='Y vs x3 (permuted data)',pch=16)
summary(result)$coefficients
T0_x2 <- abs(summary(result)$coefficients[3,3])
T0_x2
# permutations
# residuals of the reduced model
# reduced model:
# Y = beta0 + beta1*x1 + beta3*x3
regr.H02 <- lm(Y ~ x1 + x3)
residui.H02 <- regr.H02$residuals
residui.H02.perm <- residui.H02[permutazione]
# permuted y:
Y.perm.H02 <- regr.H02$fitted + residui.H02.perm
layout(matrix(1:6,nrow=3,byrow=FALSE))
plot(x1,Y,main='Y vs x1 (original data)',pch=16)
plot(x2,Y,main='Y vs x2 (original data)',pch=16)
plot(x3,Y,main='Y vs x3 (original data)',pch=16)
plot(x1,Y.perm.H02,main='Y vs x1 (permuted data)',pch=16)
plot(x2,Y.perm.H02,main='Y vs x2 (permuted data)',pch=16)
plot(x3,Y.perm.H02,main='Y vs x3 (permuted data)',pch=16)
summary(result)$coefficients
T0_x3 <- abs(summary(result)$coefficients[4,3])
T0_x3
# permutations
# residuals of the reduced model
# reduced model:
# Y = beta0 + beta1*x1 + beta2*x2
regr.H03 <- lm(Y ~ x1 + x2)
residui.H03 <- regr.H03$residuals
residui.H03.perm <- residui.H03[permutazione]
# permuted y:
Y.perm.H03 <- regr.H03$fitted + residui.H03.perm
layout(matrix(1:6,nrow=3,byrow=FALSE))
plot(x1,Y,main='Y vs x1 (original data)',pch=16)
plot(x2,Y,main='Y vs x2 (original data)',pch=16)
plot(x3,Y,main='Y vs x3 (original data)',pch=16)
plot(x1,Y.perm.H03,main='Y vs x1 (permuted data)',pch=16)
plot(x2,Y.perm.H03,main='Y vs x2 (permuted data)',pch=16)
plot(x3,Y.perm.H03,main='Y vs x3 (permuted data)',pch=16)
B <- 1000
T_H0glob <- T_H01 <- T_H02 <- T_H03 <- numeric(B)
for(perm in 1:B){
permutazione <- sample(n)
Y.perm.glob <- Y[permutazione]
T_H0glob[perm] <- summary(lm(Y.perm.glob ~ x1 + x2 + x3))$f[1]
residui.H01.perm <- residui.H01[permutazione]
Y.perm.H01 <- regr.H01$fitted + residui.H01.perm
T_H01[perm] <- abs(summary(lm(Y.perm.H01 ~ x1 + x2 + x3))$coefficients[2,3])
residui.H02.perm <- residui.H02[permutazione]
Y.perm.H02 <- regr.H02$fitted + residui.H02.perm
T_H02[perm] <- abs(summary(lm(Y.perm.H02 ~ x1 + x2 + x3))$coefficients[3,3])
residui.H03.perm <- residui.H03[permutazione]
Y.perm.H03 <- regr.H03$fitted + residui.H03.perm
T_H03[perm] <- abs(summary(lm(Y.perm.H03 ~ x1 + x2 + x3))$coefficients[4,3])
}
sum(T_H0glob>=T0_glob)/B
sum(T_H01>=T0_x1)/B
sum(T_H02>=T0_x2)/B
sum(T_H03>=T0_x3)/B
summary(result)
q()
update.packages(ask = FALSE, checkBuilt = TRUE)
library(rgl)
knitr::opts_chunk$set(echo = TRUE)
knitr::knit_hooks$set(webgl = hook_webgl)
B = 100000
seed = 26111992
library(rgl)
open3d()
plot3d(t1-t2, size=3, col='orange', aspect = F)
t1 <- read.table('meteo_data/barcellona.txt', header=T)
t2 <- read.table('meteo_data/milano.txt', header=T)
# two samples (not independent) considered as paired
library(rgl)
open3d()
plot3d(t1-t2, size=3, col='orange', aspect = F)
points3d(0,0,0, size=6)
p  <- dim(t1)[2]
n1 <- dim(t1)[1]
n2 <- dim(t2)[1]
n <- n1+n2
t1.mean <- colMeans(t1)
t2.mean <- colMeans(t2)
t1.cov  <-  cov(t1)
t2.cov  <-  cov(t2)
Sp      <- ((n1-1)*t1.cov + (n2-1)*t2.cov)/(n1+n2-2)
Spinv   <- solve(Sp)
delta.0 <- c(0,0,0)
diff <- t1-t2
diff.mean <- colMeans(diff)
diff.cov <- cov(diff)
diff.invcov <- solve(diff.cov)
T20 <- as.numeric(n1 * (diff.mean-delta.0)  %*% (diff.mean-delta.0))
T2 <- numeric(B)
set.seed(seed)
for(perm in 1:B)
{
# Random permutation
# obs: exchanging data within couples means changing the sign of the difference
signs.perm <- rbinom(n1, 1, 0.5)*2 - 1
diff_perm <- diff * matrix(signs.perm,nrow=n1,ncol=p,byrow=FALSE)
diff.mean_perm <- colMeans(diff_perm)
diff.cov_perm <- cov(diff_perm)
diff.invcov_perm <- solve(diff.cov_perm)
T2[perm] <- as.numeric(n1 * (diff.mean_perm-delta.0) %*% (diff.mean_perm-delta.0))
}
T20 <- as.numeric((diff.mean-delta.0)  %*% (diff.mean-delta.0))
# moltiplicato per n1 perché alrimenti biased (maybe?)
T2 <- numeric(B)
set.seed(seed)
for(perm in 1:B)
{
# Random permutation
# obs: exchanging data within couples means changing the sign of the difference
signs.perm <- rbinom(n1, 1, 0.5)*2 - 1
diff_perm <- diff * matrix(signs.perm,nrow=n1,ncol=p,byrow=FALSE)
diff.mean_perm <- colMeans(diff_perm)
diff.cov_perm <- cov(diff_perm)
diff.invcov_perm <- solve(diff.cov_perm)
T2[perm] <- as.numeric((diff.mean_perm-delta.0) %*% (diff.mean_perm-delta.0))
}
# plotting the permutational distribution under H0
hist(T2,xlim=range(c(T2,T20)),breaks=100)
abline(v=T20,col=3,lwd=4)
plot(ecdf(T2))
abline(v=T20,col=3,lwd=4)
# p-value
p_val <- sum(T2>=T20)/B
p_val
# uso la mahal.. distance per scalare in realtà le mie coordinateS
T20 <- as.numeric(n1 * (diff.mean-delta.0) %*% solve(diag(diag(diff.cov))) %*% (diff.mean-delta.0))
# Estimating the permutational distribution under H0
T2 <- numeric(B)
set.seed(seed)
for(perm in 1:B)
{
# Random permutation
# obs: exchanging data within couples means changing the sign of the difference
signs.perm <- rbinom(n1, 1, 0.5)*2 - 1
diff_perm <- diff * matrix(signs.perm,nrow=n1,ncol=p,byrow=FALSE)
diff.mean_perm <- colMeans(diff_perm)
diff.cov_perm <- cov(diff_perm)
diff.invcov_perm <- solve(diff.cov_perm)
T2[perm] <- as.numeric(n1 * (diff.mean_perm-delta.0) %*% solve(diag(diag(diff.cov_perm))) %*% (diff.mean_perm-delta.0))
}
# plotting the permutational distribution under H0
hist(T2,xlim=range(c(T2,T20)),breaks=100)
abline(v=T20,col=3,lwd=4)
plot(ecdf(T2))
abline(v=T20,col=3,lwd=4)
# p-value
p_val <- sum(T2>=T20)/B
p_val
T20 <- as.numeric(n1 * (diff.mean-delta.0) %*% diff.invcov %*% (diff.mean-delta.0))
# Estimating the permutational distribution under H0
set.seed(seed)
T2 <- numeric(B)
for(perm in 1:B)
{
# Random permutation
# obs: exchanging data within couples means changing the sign of the difference
signs.perm <- rbinom(n1, 1, 0.5)*2 - 1
diff_perm <- diff * matrix(signs.perm,nrow=n1,ncol=p,byrow=FALSE)
diff.mean_perm <- colMeans(diff_perm)
diff.cov_perm <- cov(diff_perm)
diff.invcov_perm <- solve(diff.cov_perm)
#T2[perm] <- as.numeric(n1 * (diff.mean_perm-delta.0) %*% (diff.mean_perm-delta.0))
#T2[perm] <- as.numeric(n1 * (diff.mean_perm-delta.0) %*% solve(diag(diag(diff.cov_perm))) %*% (diff.mean_perm-delta.0))
T2[perm] <- as.numeric(n1 * (diff.mean_perm-delta.0) %*% diff.invcov_perm %*% (diff.mean_perm-delta.0))
}
# plotting the permutational distribution under H0
hist(T2,xlim=range(c(T2,T20)),breaks=100)
abline(v=T20,col=3,lwd=4)
plot(ecdf(T2))
abline(v=T20,col=3,lwd=4)
# p-value
p_val <- sum(T2>=T20)/B
p_val
T20
# plotting the permutational distribution under H0
hist(T2,xlim=range(c(T2,T20)),breaks=100)
abline(v=T20,col=3,lwd=4)
plot(ecdf(T2))
abline(v=T20,col=3,lwd=4)
# p-value
p_val <- sum(T2>=T20)/B
p_val
library(rgl)
knitr::opts_chunk$set(echo = TRUE)
knitr::knit_hooks$set(webgl = hook_webgl)
seed=2781991
B=1000
seed=2781991
B=1000
data=stabledist::rstable(1000,1.5,0)
library(rgl)
knitr::opts_chunk$set(echo = TRUE)
knitr::knit_hooks$set(webgl = hook_webgl)
data=stabledist::rstable(1000,1.5,0)
install.packages("stabledist")
data=stabledist::rstable(1000,1.5,0)
hist(data)
median(data)
set.seed(seed)
data=stabledist::rstable(1000,1.5,0)
hist(data)
median(data)
median(data)
uni_t_perm=function(data,mu0,B=1000){
data_trans=data-mu0
T0=abs(mean(data_trans))
T_perm=numeric(B)
n=length(data)
for(perm in 1:B){
refl <- rbinom(n, 1, 0.5)*2 - 1
T_perm[perm]=abs(median(data_trans*refl))
}
return(sum(T_perm>=T0)/B)
}
# definizione della grid
grid=seq(-3,3,by=0.001)
length(grid)
library(pbapply)
install.packages("pbapply")
library(pbapply)
library(parallel)
detectCores()
cl=makeCluster(detectCores())
clusterExport(cl,varlist=list("data","uni_t_perm"))
perm_wrapper=function(grid_point){uni_t_perm(data,grid_point,B=2000)}
pval_function=pbsapply(grid,perm_wrapper,cl=cl)
plot(grid,pval_function,type='l')
range(grid[pval_function>0.05])
library(rgl)
knitr::opts_chunk$set(echo = TRUE)
knitr::knit_hooks$set(webgl = hook_webgl)
B = 1000
seed = 26111992
head(chickwts)
attach(chickwts)
summary(chickwts)
g <- nlevels(feed)
n <- dim(chickwts)[1]
plot(feed, weight, xlab='treat',col=rainbow(g),main='Original Data')
fit <- aov(weight ~ feed)
summary(fit)
# brief recap
T0 <- summary(fit)[[1]][1,4]
T0
summary(fit)
# I take the F statistic
T0 <- summary(fit)[[1]][1,4]
T0
T_stat <- numeric(B)
n <- dim(chickwts)[1]
for(perm in 1:B){
# Permutation:
permutation <- sample(1:n)
weight_perm <- weight[permutation]
fit_perm <- aov(weight_perm ~ feed)
# Test statistic:
T_stat[perm] <- summary(fit_perm)[[1]][1,4]
}
hist(T_stat,xlim=range(c(T_stat,T0)),breaks=30)
abline(v=T0,col=3,lwd=2)
plot(ecdf(T_stat),xlim=c(-1,20))
abline(v=T0,col=3,lwd=4)
# p-value
p_val <- sum(T_stat>=T0)/B
p_val
library(lmPerm)
install.packages("lmPerm")
library(lmPerm)
lmp=aovp(weight_perm ~ feed,perm="Prob",Cp=0.1)#cp is supposed to stop iterations when standard error is at that level...
summary(lmp)
lmp=aovp(weight_perm ~ feed,perm="Prob",Cp=1e-6)
summary(lmp)
lmp=aovp(weight_perm ~ feed,perm="Prob",Cp=1e-6)
summary(lmp)
lmp=aovp(weight_perm ~ feed,perm="Prob",Cp=1e-6)
summary(lmp)
lmp=aovp(weight_perm ~ feed,perm="Prob",Cp=1e-6)
summary(lmp)
data(iris)
attach(iris)
head(iris)
species.name <- factor(Species, labels=c('setosa','versicolor','virginica'))
iris4        <- iris[,1:4]
plot(iris4,col=species.name)
i1 <- which(species.name=='setosa')
i2 <- which(species.name=='versicolor')
i3 <- which(species.name=='virginica')
n1 <- length(i1)
n2 <- length(i2)
n3 <- length(i3)
n  <- n1+n2+n3
g  <- length(levels(species.name))
p  <- 4
fit <- manova(as.matrix(iris4) ~ species.name)
summary.manova(fit,test="Wilks")
T0 <- -summary.manova(fit,test="Wilks")$stats[1,2]
T0
set.seed(seed)
T_stat <- numeric(B)
for(perm in 1:B){
# choose random permutation
permutation <- sample(1:n)
species.name.perm <- species.name[permutation]
fit.perm <- manova(as.matrix(iris4) ~ species.name.perm)
T_stat[perm] <- -summary.manova(fit.perm,test="Wilks")$stats[1,2]
}
hist(T_stat,xlim=range(c(T_stat,T0)),breaks=30)
abline(v=T0,col=3,lwd=2)
plot(ecdf(T_stat),xlim=c(-2,1))
abline(v=T0,col=3,lwd=4)
# p-value
p_val <- sum(T_stat>=T0)/B
p_val
install.packages("cmdstanr", repos = c("https://mc-stan.org/r-packages/", getOption("repos")))
cmdstanr::install_cmdstan()
check_cmdstan_toolchain(fix = TRUE)
library(cmdstanr)
check_cmdstan_toolchain(fix = TRUE)
cmdstanr::install_cmdstan()
install.packages("cmdstanr", repos = c("https://mc-stan.org/r-packages/", getOption("repos")))
cmdstanr::install_cmdstan()
library(rjags)
library(coda)
# for plots
library(ggplot2)
library(tidyr)
library(dplyr)
library(purrr)
library(ggsci)
require(gplots)
require(ggpubr)
setwd("~/UNI/NECSTCamp/StPetersbirg_git/ECGanalysis")
library(fda)
library(dplyr)
df <- read.csv('HB_I03/Signals.csv', header = TRUE)
head(df)
df %>% select(-mean)
HB_mean = rowMeans(df)
plot(HB_mean, lwd = 2, col = 'black', type = 'l')
for ( c in df ) lines( c, type="l", col = 'grey' )
lines(HB_mean, lwd = 2, col = 'black', type = 'l')
punti = read.csv('HB_I01/Peaks.csv', header = TRUE)
head(punti)
punti_medi = round(colMeans(punti))
rpeak = 90 +1
plot(HB_mean, lwd = 2, col = 'black', type = 'l')
points(rpeak+punti_medi,HB_mean[rpeak + punti_medi])
abline(v = rpeak, col = 'red')
# provo a spostare punti messi very male
abline(v = 45) # questo deve essere il nuovo P_peak
rpeak + punti_medi[1:3] - 45
punti_medi[1:3] = punti_medi[1:3] - 15
abline(v = punti_medi[1:3] + rpeak, col = 'red')
# T_peak
abline(v = 158)
158 - rpeak - punti_medi[8]
punti_medi[8] = 158 - rpeak
#T_offset
abline(v = 170)
170 - rpeak - punti_medi[10]
punti_medi[10] = 170 - rpeak
plot(HB_mean, lwd = 2, col = 'black', type = 'l')
points(rpeak+punti_medi,HB_mean[rpeak + punti_medi])
abline(v = rpeak, col = 'red')
end = length(HB_mean)
time = 1:end
n = 20 # a caso
frazioni = c('R' = 2/5, 'P' = 1/6, 'T' = 1/6)
# 1/3 dei knots totali in curva R
nodiR = seq(from = rpeak + punti_medi[5] - 1,to = rpeak + punti_medi[7] + 2,length.out = n*frazioni[1])
lenR = length(nodiR)
eps = nodiR[2]-nodiR[1]
# 1/4 dei knots totali in curva P
nodiP = seq(from = rpeak + punti_medi[2] - 3,to = rpeak + punti_medi[3] + 3,length.out = n*frazioni[2])
lenP = length(nodiP)
# 1/4 dei knots totali in curva T
nodiT = seq(from = rpeak + punti_medi[9] - 3,to = rpeak + punti_medi[10] + 3,length.out = n*frazioni[3])
lenT = length(nodiT)
n - lenR - lenP - lenT    # nodi mancanti che devo assegnare
tratto1 = 1:(nodiP[1]-1)  # nodi tra 1 e curva P
len1 = length(tratto1)
tratto2 = (nodiP[lenP]+1):(nodiR[1]-1)  # nodi tra P e R
len2 = length(tratto2)
tratto3 = (nodiR[lenR]+1):(nodiT[1]-1)  # nodi tra R e T
len3 = length(tratto3)
tratto4 = (nodiT[lenT]+1):(length(HB_mean))  # nodi tra T e end
len4 = length(tratto4)
other = c(tratto1,tratto2,tratto3,tratto4)
length(other)
interval = (length(other) / (n*(1-frazioni[1]-frazioni[2]-frazioni[3])))  # splitto uniformemente i restanti valori
nodi_other = other[seq(1, length(other), interval)]
nodi_other=c(nodi_other,end)
length(nodi_other)
knots = sort(c(nodiR,nodiP,nodiT,nodi_other))
length(knots)
indeces = rep(0, length(knots)-1)
for (i in 1:(length(knots)-1)){
if (knots[i+1] - knots[i] < eps) indeces[i] = i
}
knots = knots[-indeces]
knots = c(knots,rpeak)
length(knots)
plot(HB_mean, lwd = 2, col = 'black', type = 'l', ylim = c(-0.2,0.5))
points(knots,rep(-0.2,length(knots)), pch = 4)
abline(h = -0.2, col = 'red')
abline(v = c(punti_medi[c(2,3,5,7,9,10)]+rpeak), lty = 2, col = 'red')
# proviamo lo smoothing con questi nodi
basis <- create.bspline.basis(rangeval=c(1,end), breaks = knots, norder=3)
knots
knots = sort(c(knots,rpeak))
length(knots)
knots
# proviamo lo smoothing con questi nodi
basis <- create.bspline.basis(rangeval=c(1,end), breaks = knots, norder=3)
Xsp <- smooth.basis(argvals=time, y=HB_mean, fdParobj=basis)
Xsp0 <- eval.fd(time, Xsp$fd)
plot(time,HB_mean,xlab="t",ylab="observed data")
points(time,Xsp0 ,type="l",col="green",lwd=2)
plot(basis)
print('Number of knots: 'length(knots)
)
print('Number of knots: 'length(knots))
print('Number of knots: ',length(knots))
print(paste('Number of knots: ',length(knots)))
# function to define the distribution of points
# arguments:
# n: integer, number of knots in the interval
# lenHB: integer, length of the
#
find_knots <- function(n,lenHB,rpeak, fraction = c('R' = 2/5, 'P' = 1/6, 'T' = 1/6)) {
# knots in curva R
nodiR = seq(from = rpeak + punti_medi[5] - 1,to = rpeak + punti_medi[7] + 2,length.out = n*frazioni[1])
lenR = length(nodiR)
# knots in curva P
nodiP = seq(from = rpeak + punti_medi[2] - 3,to = rpeak + punti_medi[3] + 3,length.out = n*frazioni[2])
lenP = length(nodiP)
# knots in curva T
nodiT = seq(from = rpeak + punti_medi[9] - 3,to = rpeak + punti_medi[10] + 3,length.out = n*frazioni[3])
lenT = length(nodiT)
# tratti mancanti
n - lenR - lenP - lenT    # nodi mancanti che devo assegnare
tratto1 = 1:(nodiP[1]-1)  # nodi tra 1 e curva P
len1 = length(tratto1)
tratto2 = (nodiP[lenP]+1):(nodiR[1]-1)  # nodi tra P e R
len2 = length(tratto2)
tratto3 = (nodiR[lenR]+1):(nodiT[1]-1)  # nodi tra R e T
len3 = length(tratto3)
tratto4 = (nodiT[lenT]+1):(length(HB_mean))  # nodi tra T e end
len4 = length(tratto4)
other = c(tratto1,tratto2,tratto3,tratto4)
length(other)
interval = (length(other) / (n*(1-frazioni[1]-frazioni[2]-frazioni[3])))  # splitto uniformemente i restanti valori
nodi_other = other[seq(1, length(other), interval)]
nodi_other=c(nodi_other,end)
length(nodi_other)
knots = sort(c(nodiR,nodiP,nodiT,nodi_other))
# rimuovo knots troppo vicini
indeces = rep(0, length(knots)-1)
eps = nodiR[2]-nodiR[1]
for (i in 1:(length(knots)-1)){
if (knots[i+1] - knots[i] < eps) indeces[i] = i
}
knots = knots[-indeces]
# aggiungo un knot anche nel picco
knots = sort(c(knots,rpeak))
print(paste('Number of knots: ',length(knots)))
# plot del segnale con punti di intersse e knots
plot(HB_mean, lwd = 2, col = 'black', type = 'l', ylim = c(-0.2,0.5))
points(knots,rep(-0.2,length(knots)), pch = 4)
abline(h = -0.2, col = 'red')
abline(v = c(punti_medi[c(2,3,5,7,9,10)]+rpeak), lty = 2, col = 'red')
return(knots)
}
# prova funzionamento funzione
nodi = find_knots(n,end,rpeak)
nodi
# prova funzionamento funzione
nodi = find_knots(25,end,rpeak)
nodi
