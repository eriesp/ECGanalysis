rownames(quantiles) <- c("band1_R","band2_G","band3_B")
min_my_clust <- aggregate(.~ Clusters, FUN = min, data = df_full[ , c(1,2,3)] ) [my_clust,2:4]
max_my_clust <- aggregate(.~ Clusters, FUN = max, data = df_full[ , c(1,2,3)] ) [my_clust,2:4]
lenght_my_clust <- aggregate(.~ Clusters, FUN = length, data = df_full[ , c(1,2,3)] ) [my_clust,2:4]
return(list(mean = mean_of_my_clust,
# variance = var_of_my_clust,
cov.matrix = cov_matrix,
quantiles = quantiles,
min = min_my_clust,
max = max_my_clust,
lenght = lenght_my_clust))
}
save(get.img.values, hier.clust,opt.cluster, select.rows, vi,
file = "~/UNI/APPLIED STATISTICS/PROJECT - Road pavement detection/funcs.RData")
# Using the R package fdakma
library(fdakma)
help(kma.data)
data(kma.data)
x <- kma.data$x   # abscissas
y0 <- kma.data$y0 # evaluations of original functions
y1 <- kma.data$y1 # evaluations of original functions' first derivatives
# Plot of original functions
matplot(t(x),t(y0), type='l', xlab='x', ylab='orig.func')
title ('Original functions')
# Plot of original functions
matplot(t(x),t(y0), type='l', xlab='x', ylab='orig.func')
set.seed(24021979)
n <- 50
# covariate values
x1 <- runif(n,0,10)
x2 <- (1:n)/5
x3 <- rnorm(n,5,5)
b0 <- 2
b1 <- 4
b2 <- -2
b3 <- 0
Y <- b0 + b1*x1 + b2*x2 + b3*x3 + runif(n,-5,5)
plot(x1,Y,pch=16)
plot(x2,Y,pch=16)
plot(x3,Y,pch=16)
result <- lm(Y ~ x1 + x2 + x3)
summary(result)
qqnorm(result$residuals)
shapiro.test(result$residuals)
# Overall model
# H0: beta1 = beta2 = beta3 = 0
# test statistic
T0_glob <- summary(result)$f[1]
T0_glob
# permutations
permutazione <- sample(n)
Y.perm.glob <- Y[permutazione]
permutazione
# in this case permuting the responses or the residuals is the same
res.H0glob <- Y - mean(Y)
Y.perm.glob
mean(Y) + res.H0glob[permutazione]
layout(matrix(1:6,nrow=3,byrow=FALSE))
plot(x1,Y,main='Y vs x1 (original data)',pch=16)
plot(x2,Y,main='Y vs x2 (original data)',pch=16)
plot(x3,Y,main='Y vs x3 (original data)',pch=16)
plot(x1,Y.perm.glob,main='Y vs x1 (permuted data)',pch=16)
plot(x2,Y.perm.glob,main='Y vs x2 (permuted data)',pch=16)
plot(x3,Y.perm.glob,main='Y vs x3 (permuted data)',pch=16)
summary(result)$coefficients
T0_x1 <- abs(summary(result)$coefficients[2,3])
T0_x1
regr.H01 <- lm(Y ~ x2 + x3)
residui.H01 <- regr.H01$residuals
residui.H01.perm <- residui.H01[permutazione]
# permuted y:
Y.perm.H01 <- regr.H01$fitted + residui.H01.perm
layout(matrix(1:6,nrow=3,byrow=FALSE))
plot(x1,Y,main='Y vs x1 (original data)',pch=16)
plot(x2,Y,main='Y vs x2 (original data)',pch=16)
plot(x3,Y,main='Y vs x3 (original data)',pch=16)
plot(x1,Y.perm.H01,main='Y vs x1 (permuted data)',pch=16)
plot(x2,Y.perm.H01,main='Y vs x2 (permuted data)',pch=16)
plot(x3,Y.perm.H01,main='Y vs x3 (permuted data)',pch=16)
summary(result)$coefficients
T0_x2 <- abs(summary(result)$coefficients[3,3])
T0_x2
# permutations
# residuals of the reduced model
# reduced model:
# Y = beta0 + beta1*x1 + beta3*x3
regr.H02 <- lm(Y ~ x1 + x3)
residui.H02 <- regr.H02$residuals
residui.H02.perm <- residui.H02[permutazione]
# permuted y:
Y.perm.H02 <- regr.H02$fitted + residui.H02.perm
layout(matrix(1:6,nrow=3,byrow=FALSE))
plot(x1,Y,main='Y vs x1 (original data)',pch=16)
plot(x2,Y,main='Y vs x2 (original data)',pch=16)
plot(x3,Y,main='Y vs x3 (original data)',pch=16)
plot(x1,Y.perm.H02,main='Y vs x1 (permuted data)',pch=16)
plot(x2,Y.perm.H02,main='Y vs x2 (permuted data)',pch=16)
plot(x3,Y.perm.H02,main='Y vs x3 (permuted data)',pch=16)
summary(result)$coefficients
T0_x3 <- abs(summary(result)$coefficients[4,3])
T0_x3
# permutations
# residuals of the reduced model
# reduced model:
# Y = beta0 + beta1*x1 + beta2*x2
regr.H03 <- lm(Y ~ x1 + x2)
residui.H03 <- regr.H03$residuals
residui.H03.perm <- residui.H03[permutazione]
# permuted y:
Y.perm.H03 <- regr.H03$fitted + residui.H03.perm
layout(matrix(1:6,nrow=3,byrow=FALSE))
plot(x1,Y,main='Y vs x1 (original data)',pch=16)
plot(x2,Y,main='Y vs x2 (original data)',pch=16)
plot(x3,Y,main='Y vs x3 (original data)',pch=16)
plot(x1,Y.perm.H03,main='Y vs x1 (permuted data)',pch=16)
plot(x2,Y.perm.H03,main='Y vs x2 (permuted data)',pch=16)
plot(x3,Y.perm.H03,main='Y vs x3 (permuted data)',pch=16)
B <- 1000
T_H0glob <- T_H01 <- T_H02 <- T_H03 <- numeric(B)
for(perm in 1:B){
permutazione <- sample(n)
Y.perm.glob <- Y[permutazione]
T_H0glob[perm] <- summary(lm(Y.perm.glob ~ x1 + x2 + x3))$f[1]
residui.H01.perm <- residui.H01[permutazione]
Y.perm.H01 <- regr.H01$fitted + residui.H01.perm
T_H01[perm] <- abs(summary(lm(Y.perm.H01 ~ x1 + x2 + x3))$coefficients[2,3])
residui.H02.perm <- residui.H02[permutazione]
Y.perm.H02 <- regr.H02$fitted + residui.H02.perm
T_H02[perm] <- abs(summary(lm(Y.perm.H02 ~ x1 + x2 + x3))$coefficients[3,3])
residui.H03.perm <- residui.H03[permutazione]
Y.perm.H03 <- regr.H03$fitted + residui.H03.perm
T_H03[perm] <- abs(summary(lm(Y.perm.H03 ~ x1 + x2 + x3))$coefficients[4,3])
}
sum(T_H0glob>=T0_glob)/B
sum(T_H01>=T0_x1)/B
sum(T_H02>=T0_x2)/B
sum(T_H03>=T0_x3)/B
summary(result)
q()
update.packages(ask = FALSE, checkBuilt = TRUE)
library(rgl)
knitr::opts_chunk$set(echo = TRUE)
knitr::knit_hooks$set(webgl = hook_webgl)
B = 100000
seed = 26111992
library(rgl)
open3d()
plot3d(t1-t2, size=3, col='orange', aspect = F)
t1 <- read.table('meteo_data/barcellona.txt', header=T)
t2 <- read.table('meteo_data/milano.txt', header=T)
# two samples (not independent) considered as paired
library(rgl)
open3d()
plot3d(t1-t2, size=3, col='orange', aspect = F)
points3d(0,0,0, size=6)
p  <- dim(t1)[2]
n1 <- dim(t1)[1]
n2 <- dim(t2)[1]
n <- n1+n2
t1.mean <- colMeans(t1)
t2.mean <- colMeans(t2)
t1.cov  <-  cov(t1)
t2.cov  <-  cov(t2)
Sp      <- ((n1-1)*t1.cov + (n2-1)*t2.cov)/(n1+n2-2)
Spinv   <- solve(Sp)
delta.0 <- c(0,0,0)
diff <- t1-t2
diff.mean <- colMeans(diff)
diff.cov <- cov(diff)
diff.invcov <- solve(diff.cov)
T20 <- as.numeric(n1 * (diff.mean-delta.0)  %*% (diff.mean-delta.0))
T2 <- numeric(B)
set.seed(seed)
for(perm in 1:B)
{
# Random permutation
# obs: exchanging data within couples means changing the sign of the difference
signs.perm <- rbinom(n1, 1, 0.5)*2 - 1
diff_perm <- diff * matrix(signs.perm,nrow=n1,ncol=p,byrow=FALSE)
diff.mean_perm <- colMeans(diff_perm)
diff.cov_perm <- cov(diff_perm)
diff.invcov_perm <- solve(diff.cov_perm)
T2[perm] <- as.numeric(n1 * (diff.mean_perm-delta.0) %*% (diff.mean_perm-delta.0))
}
T20 <- as.numeric((diff.mean-delta.0)  %*% (diff.mean-delta.0))
# moltiplicato per n1 perché alrimenti biased (maybe?)
T2 <- numeric(B)
set.seed(seed)
for(perm in 1:B)
{
# Random permutation
# obs: exchanging data within couples means changing the sign of the difference
signs.perm <- rbinom(n1, 1, 0.5)*2 - 1
diff_perm <- diff * matrix(signs.perm,nrow=n1,ncol=p,byrow=FALSE)
diff.mean_perm <- colMeans(diff_perm)
diff.cov_perm <- cov(diff_perm)
diff.invcov_perm <- solve(diff.cov_perm)
T2[perm] <- as.numeric((diff.mean_perm-delta.0) %*% (diff.mean_perm-delta.0))
}
# plotting the permutational distribution under H0
hist(T2,xlim=range(c(T2,T20)),breaks=100)
abline(v=T20,col=3,lwd=4)
plot(ecdf(T2))
abline(v=T20,col=3,lwd=4)
# p-value
p_val <- sum(T2>=T20)/B
p_val
# uso la mahal.. distance per scalare in realtà le mie coordinateS
T20 <- as.numeric(n1 * (diff.mean-delta.0) %*% solve(diag(diag(diff.cov))) %*% (diff.mean-delta.0))
# Estimating the permutational distribution under H0
T2 <- numeric(B)
set.seed(seed)
for(perm in 1:B)
{
# Random permutation
# obs: exchanging data within couples means changing the sign of the difference
signs.perm <- rbinom(n1, 1, 0.5)*2 - 1
diff_perm <- diff * matrix(signs.perm,nrow=n1,ncol=p,byrow=FALSE)
diff.mean_perm <- colMeans(diff_perm)
diff.cov_perm <- cov(diff_perm)
diff.invcov_perm <- solve(diff.cov_perm)
T2[perm] <- as.numeric(n1 * (diff.mean_perm-delta.0) %*% solve(diag(diag(diff.cov_perm))) %*% (diff.mean_perm-delta.0))
}
# plotting the permutational distribution under H0
hist(T2,xlim=range(c(T2,T20)),breaks=100)
abline(v=T20,col=3,lwd=4)
plot(ecdf(T2))
abline(v=T20,col=3,lwd=4)
# p-value
p_val <- sum(T2>=T20)/B
p_val
T20 <- as.numeric(n1 * (diff.mean-delta.0) %*% diff.invcov %*% (diff.mean-delta.0))
# Estimating the permutational distribution under H0
set.seed(seed)
T2 <- numeric(B)
for(perm in 1:B)
{
# Random permutation
# obs: exchanging data within couples means changing the sign of the difference
signs.perm <- rbinom(n1, 1, 0.5)*2 - 1
diff_perm <- diff * matrix(signs.perm,nrow=n1,ncol=p,byrow=FALSE)
diff.mean_perm <- colMeans(diff_perm)
diff.cov_perm <- cov(diff_perm)
diff.invcov_perm <- solve(diff.cov_perm)
#T2[perm] <- as.numeric(n1 * (diff.mean_perm-delta.0) %*% (diff.mean_perm-delta.0))
#T2[perm] <- as.numeric(n1 * (diff.mean_perm-delta.0) %*% solve(diag(diag(diff.cov_perm))) %*% (diff.mean_perm-delta.0))
T2[perm] <- as.numeric(n1 * (diff.mean_perm-delta.0) %*% diff.invcov_perm %*% (diff.mean_perm-delta.0))
}
# plotting the permutational distribution under H0
hist(T2,xlim=range(c(T2,T20)),breaks=100)
abline(v=T20,col=3,lwd=4)
plot(ecdf(T2))
abline(v=T20,col=3,lwd=4)
# p-value
p_val <- sum(T2>=T20)/B
p_val
T20
# plotting the permutational distribution under H0
hist(T2,xlim=range(c(T2,T20)),breaks=100)
abline(v=T20,col=3,lwd=4)
plot(ecdf(T2))
abline(v=T20,col=3,lwd=4)
# p-value
p_val <- sum(T2>=T20)/B
p_val
library(rgl)
knitr::opts_chunk$set(echo = TRUE)
knitr::knit_hooks$set(webgl = hook_webgl)
seed=2781991
B=1000
seed=2781991
B=1000
data=stabledist::rstable(1000,1.5,0)
library(rgl)
knitr::opts_chunk$set(echo = TRUE)
knitr::knit_hooks$set(webgl = hook_webgl)
data=stabledist::rstable(1000,1.5,0)
install.packages("stabledist")
data=stabledist::rstable(1000,1.5,0)
hist(data)
median(data)
set.seed(seed)
data=stabledist::rstable(1000,1.5,0)
hist(data)
median(data)
median(data)
uni_t_perm=function(data,mu0,B=1000){
data_trans=data-mu0
T0=abs(mean(data_trans))
T_perm=numeric(B)
n=length(data)
for(perm in 1:B){
refl <- rbinom(n, 1, 0.5)*2 - 1
T_perm[perm]=abs(median(data_trans*refl))
}
return(sum(T_perm>=T0)/B)
}
# definizione della grid
grid=seq(-3,3,by=0.001)
length(grid)
library(pbapply)
install.packages("pbapply")
library(pbapply)
library(parallel)
detectCores()
cl=makeCluster(detectCores())
clusterExport(cl,varlist=list("data","uni_t_perm"))
perm_wrapper=function(grid_point){uni_t_perm(data,grid_point,B=2000)}
pval_function=pbsapply(grid,perm_wrapper,cl=cl)
plot(grid,pval_function,type='l')
range(grid[pval_function>0.05])
library(rgl)
knitr::opts_chunk$set(echo = TRUE)
knitr::knit_hooks$set(webgl = hook_webgl)
B = 1000
seed = 26111992
head(chickwts)
attach(chickwts)
summary(chickwts)
g <- nlevels(feed)
n <- dim(chickwts)[1]
plot(feed, weight, xlab='treat',col=rainbow(g),main='Original Data')
fit <- aov(weight ~ feed)
summary(fit)
# brief recap
T0 <- summary(fit)[[1]][1,4]
T0
summary(fit)
# I take the F statistic
T0 <- summary(fit)[[1]][1,4]
T0
T_stat <- numeric(B)
n <- dim(chickwts)[1]
for(perm in 1:B){
# Permutation:
permutation <- sample(1:n)
weight_perm <- weight[permutation]
fit_perm <- aov(weight_perm ~ feed)
# Test statistic:
T_stat[perm] <- summary(fit_perm)[[1]][1,4]
}
hist(T_stat,xlim=range(c(T_stat,T0)),breaks=30)
abline(v=T0,col=3,lwd=2)
plot(ecdf(T_stat),xlim=c(-1,20))
abline(v=T0,col=3,lwd=4)
# p-value
p_val <- sum(T_stat>=T0)/B
p_val
library(lmPerm)
install.packages("lmPerm")
library(lmPerm)
lmp=aovp(weight_perm ~ feed,perm="Prob",Cp=0.1)#cp is supposed to stop iterations when standard error is at that level...
summary(lmp)
lmp=aovp(weight_perm ~ feed,perm="Prob",Cp=1e-6)
summary(lmp)
lmp=aovp(weight_perm ~ feed,perm="Prob",Cp=1e-6)
summary(lmp)
lmp=aovp(weight_perm ~ feed,perm="Prob",Cp=1e-6)
summary(lmp)
lmp=aovp(weight_perm ~ feed,perm="Prob",Cp=1e-6)
summary(lmp)
data(iris)
attach(iris)
head(iris)
species.name <- factor(Species, labels=c('setosa','versicolor','virginica'))
iris4        <- iris[,1:4]
plot(iris4,col=species.name)
i1 <- which(species.name=='setosa')
i2 <- which(species.name=='versicolor')
i3 <- which(species.name=='virginica')
n1 <- length(i1)
n2 <- length(i2)
n3 <- length(i3)
n  <- n1+n2+n3
g  <- length(levels(species.name))
p  <- 4
fit <- manova(as.matrix(iris4) ~ species.name)
summary.manova(fit,test="Wilks")
T0 <- -summary.manova(fit,test="Wilks")$stats[1,2]
T0
set.seed(seed)
T_stat <- numeric(B)
for(perm in 1:B){
# choose random permutation
permutation <- sample(1:n)
species.name.perm <- species.name[permutation]
fit.perm <- manova(as.matrix(iris4) ~ species.name.perm)
T_stat[perm] <- -summary.manova(fit.perm,test="Wilks")$stats[1,2]
}
hist(T_stat,xlim=range(c(T_stat,T0)),breaks=30)
abline(v=T0,col=3,lwd=2)
plot(ecdf(T_stat),xlim=c(-2,1))
abline(v=T0,col=3,lwd=4)
# p-value
p_val <- sum(T_stat>=T0)/B
p_val
install.packages("cmdstanr", repos = c("https://mc-stan.org/r-packages/", getOption("repos")))
cmdstanr::install_cmdstan()
check_cmdstan_toolchain(fix = TRUE)
library(cmdstanr)
check_cmdstan_toolchain(fix = TRUE)
cmdstanr::install_cmdstan()
install.packages("cmdstanr", repos = c("https://mc-stan.org/r-packages/", getOption("repos")))
cmdstanr::install_cmdstan()
library(rjags)
library(coda)
# for plots
library(ggplot2)
library(tidyr)
library(dplyr)
library(purrr)
library(ggsci)
require(gplots)
require(ggpubr)
setwd("~/UNI/NECSTCamp/StPetersburgINCART")
df1 <- read.csv('1-FirstTenSignals.csv', header = True)
df1 <- read.csv('1-FirstTenSignals.csv', header = TRUE)
head(df1)
matplot(df1)
matplot(df1['I01'], type = 'l')
setwd("~/UNI/NECSTCamp/StPetersburgINCART")
df1 <- read.csv('HB_I01.csv', header = TRUE)
df1 <- read.csv('HB_I01/Signals.csv', header = TRUE)
head(df1)
matplot(df1['X0'], type = 'l')
peaks = read.csv('HB_I01/Peaks.csv', header = TRUE)
head(peaks)
abline(v = 85, color = 'r', type = '-')
abline(v = 85, color = 'r', type = '--')
abline(v = 85, col = 'r', lwd= '--')
abline(v = 85, col = 'red', lty= '--')
abline(v = 85, col = "red", lty= "--")
abline(v = 85, col = "red", lty= 1)
abline(v = 85, col = "red", lty= 2)
abline(v = 85, col = "red", lty= 3)
abline(v = 85, col = "red", lty= 4)
abline(v = 85, col = "red", lty= 5)
head(peaks)
che
plle
head(peaks)
peaks[1,1]
peaks[0,1]
abline(v = peaks[1,1] + 85, col = 'blue')
abline(v = peaks[1,2] + 85, col = 'green')
abline(v = peaks[1,4] + 85, col = 'green')
abline(v = peaks[1,7] + 85, col = 'yellow')
df1 <- read.csv('HB_I01/Signals.csv', header = TRUE)
head(df1)
matplot(df1['X0'], type = 'l')
abline(v = 85, col = "red")
peaks = read.csv('HB_I01/Peaks.csv', header = TRUE)
head(peaks)
matplot(df1['X0'], type = 'l')
abline(v = 85, col = "red")
abline(v = peaks[1,1] + 85, col = 'blue')
abline(v = peaks[1,4] + 85, col = 'green')
abline(v = peaks[1,7] + 85, col = 'yellow')
abline(v = peaks[1,8] + 85, col = 'pink')
library(fda)
length(df1['x0'])
length(df1['X0'])
dim(df1['X0'])
time = 1:169
basis <- create.fourier.basis(rangeval=c(0,169),nbasis=60)
data_HB.fb <- Data2fd(y = df1['X0'],argvals = time,basisobj = basis)
firstHB = df1['X0']
basis <- create.fourier.basis(rangeval=c(0,169),nbasis=60)
data_HB.fb <- Data2fd(y = firstHB,argvals = time,basisobj = basis)
basis
plot(basis)
is(firstHB)
data_W <- CanadianWeather$dailyAv[,,1]
is(data_W)
firstHB = array(df1['X0'])
is(firstHB)
firstHB = vector(df1['X0'])
firstHB = df1$X0
is(firstHB)
data_HB.fb <- Data2fd(y = firstHB,argvals = time,basisobj = basis)
plot.fd(data_W.fd.3)
plot.fd(data_HB.fb)
points(time,firstHB ,type="l",col="blue",lwd=2)
plot.fd(data_HB.fb, lwd=2)
points(time,firstHB ,type="l",col="blue",lwd=1)
points(time,firstHB ,col="blue",lwd=1)
points(time,firstHB ,col="blue")
plot.fd(data_HB.fb)
points(time,firstHB ,col="blue")
basis <- create.fourier.basis(rangeval=c(0,169),nbasis=30)
data_HB.fb <- Data2fd(y = firstHB,argvals = time,basisobj = basis)
plot.fd(data_HB.fb)
points(time,firstHB ,type="l",col="blue",lwd=1)
basis <- create.fourier.basis(rangeval=c(0,169),nbasis=31)
data_HB.fb <- Data2fd(y = firstHB,argvals = time,basisobj = basis)
plot.fd(data_HB.fb)
points(time,firstHB ,type="l",col="blue",lwd=1)
basis <- create.fourier.basis(rangeval=c(0,169),nbasis=15)
data_HB.fb <- Data2fd(y = firstHB,argvals = time,basisobj = basis)
plot.fd(data_HB.fb)
points(time,firstHB ,type="l",col="blue",lwd=1)
basis <- create.fourier.basis(rangeval=c(0,169),nbasis=30)
basis <- create.fourier.basis(rangeval=c(0,169),nbasis=31)
data_HB.fb <- Data2fd(y = firstHB,argvals = time,basisobj = basis)
plot.fd(data_HB.fb)
points(time,firstHB ,type="l",col="blue",lwd=1)
basis <- create.fourier.basis(rangeval=c(0,168),nbasis=31)
data_HB.fb <- Data2fd(y = firstHB,argvals = time,basisobj = basis)
basis <- create.fourier.basis(rangeval=c(0,169),nbasis=31)
data_HB.fb <- Data2fd(y = firstHB,argvals = time,basisobj = basis)
plot.fd(data_HB.fb)
points(time,firstHB ,type="l",col="blue",lwd=1)
